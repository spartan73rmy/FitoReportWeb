/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

export interface IReporteClient {
  agregar(command: AgregarReporteCommand): Promise<AgregarReporteResponse>;
  get(idReport: number): Promise<GetReporteResponse>;
  getSearchList(): Promise<GetSearchReportListResponse>;
}

export class ReporteClient implements IReporteClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  agregar(
    command: AgregarReporteCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarReporteResponse> {
    let url_ = this.baseUrl + "/api/Reporte/Agregar";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAgregar(_response);
      });
  }

  protected processAgregar(
    response: AxiosResponse
  ): Promise<AgregarReporteResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarReporteResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarReporteResponse>(<any>null);
  }

  get(
    idReport: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetReporteResponse> {
    let url_ = this.baseUrl + "/api/Reporte/Get/{idReport}";
    if (idReport === undefined || idReport === null)
      throw new Error("The parameter 'idReport' must be defined.");
    url_ = url_.replace("{idReport}", encodeURIComponent("" + idReport));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(response: AxiosResponse): Promise<GetReporteResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetReporteResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetReporteResponse>(<any>null);
  }

  getSearchList(
    cancelToken?: CancelToken | undefined
  ): Promise<GetSearchReportListResponse> {
    let url_ = this.baseUrl + "/api/Reporte/GetSearchList";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSearchList(_response);
      });
  }

  protected processGetSearchList(
    response: AxiosResponse
  ): Promise<GetSearchReportListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetSearchReportListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetSearchReportListResponse>(<any>null);
  }
}

export interface IArchivosClient {
  agregarArchivo(
    command: FileParameter | null | undefined
  ): Promise<AgregarArchivoResponse>;
  generaTokenDescarga(
    query: TokenDescargaQuery
  ): Promise<TokenDescargaResponse>;
  descargarArchivo(
    hash: string | null,
    token: string | null | undefined
  ): Promise<FileResponse>;
}

export class ArchivosClient implements IArchivosClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  agregarArchivo(
    command: FileParameter | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarArchivoResponse> {
    let url_ = this.baseUrl + "/api/Archivos/AgregarArchivo";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (command !== null && command !== undefined)
      content_.append(
        "command",
        command.data,
        command.fileName ? command.fileName : "command"
      );

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAgregarArchivo(_response);
      });
  }

  protected processAgregarArchivo(
    response: AxiosResponse
  ): Promise<AgregarArchivoResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarArchivoResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarArchivoResponse>(<any>null);
  }

  generaTokenDescarga(
    query: TokenDescargaQuery,
    cancelToken?: CancelToken | undefined
  ): Promise<TokenDescargaResponse> {
    let url_ = this.baseUrl + "/api/Archivos/GeneraTokenDescarga";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGeneraTokenDescarga(_response);
      });
  }

  protected processGeneraTokenDescarga(
    response: AxiosResponse
  ): Promise<TokenDescargaResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TokenDescargaResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TokenDescargaResponse>(<any>null);
  }

  descargarArchivo(
    hash: string | null,
    token: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/Archivos/DescargarArchivo/{hash}?";
    if (hash === undefined || hash === null)
      throw new Error("The parameter 'hash' must be defined.");
    url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
    if (token !== undefined && token !== null)
      url_ += "token=" + encodeURIComponent("" + token) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDescargarArchivo(_response);
      });
  }

  protected processDescargarArchivo(
    response: AxiosResponse
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileResponse>(<any>null);
  }
}

export interface ICuentaClient {
  confirmar(token: string | null | undefined): Promise<ConfirmarEmailResponse>;
  ingresar(query: GetUsuarioLoginQuery): Promise<IngresarResponse>;
  refreshCredentials(
    query: RefreshCredentialsCommand
  ): Promise<IngresarResponse>;
  invalidaToken(query: InvalidaTokenCommand): Promise<InvalidaTokenResponse>;
  recuperaPasswordGeneraToken(
    query: RecuperaPasswordGeneraTokenCommand
  ): Promise<RecuperaPasswordGeneraTokenResponse>;
  recuperaPassword(
    query: RecuperaPasswordCommand
  ): Promise<RecuperaPasswordResponse>;
  ping(): Promise<FileResponse>;
  createUser(command: CreateUsuarioCommand): Promise<CreateUsuarioResponse>;
  reenviar(command: ReenviarEmailCommand): Promise<ReenviarEmailResponse>;
}

export class CuentaClient implements ICuentaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  confirmar(
    token: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ConfirmarEmailResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Confirmar?";
    if (token !== undefined && token !== null)
      url_ += "Token=" + encodeURIComponent("" + token) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processConfirmar(_response);
      });
  }

  protected processConfirmar(
    response: AxiosResponse
  ): Promise<ConfirmarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ConfirmarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ConfirmarEmailResponse>(<any>null);
  }

  ingresar(
    query: GetUsuarioLoginQuery,
    cancelToken?: CancelToken | undefined
  ): Promise<IngresarResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Ingresar";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processIngresar(_response);
      });
  }

  protected processIngresar(
    response: AxiosResponse
  ): Promise<IngresarResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IngresarResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<IngresarResponse>(<any>null);
  }

  refreshCredentials(
    query: RefreshCredentialsCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<IngresarResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RefreshCredentials";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRefreshCredentials(_response);
      });
  }

  protected processRefreshCredentials(
    response: AxiosResponse
  ): Promise<IngresarResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IngresarResponse.fromJS(resultData200);
      return result200;
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ProblemDetails.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else {
      const _responseText = response.data;
      let resultdefault: any = null;
      let resultDatadefault = _responseText;
      resultdefault = ProblemDetails.fromJS(resultDatadefault);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        resultdefault
      );
    }
  }

  invalidaToken(
    query: InvalidaTokenCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<InvalidaTokenResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/InvalidaToken";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processInvalidaToken(_response);
      });
  }

  protected processInvalidaToken(
    response: AxiosResponse
  ): Promise<InvalidaTokenResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = InvalidaTokenResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<InvalidaTokenResponse>(<any>null);
  }

  recuperaPasswordGeneraToken(
    query: RecuperaPasswordGeneraTokenCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<RecuperaPasswordGeneraTokenResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RecuperaPasswordGeneraToken";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRecuperaPasswordGeneraToken(_response);
      });
  }

  protected processRecuperaPasswordGeneraToken(
    response: AxiosResponse
  ): Promise<RecuperaPasswordGeneraTokenResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RecuperaPasswordGeneraTokenResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<RecuperaPasswordGeneraTokenResponse>(<any>null);
  }

  recuperaPassword(
    query: RecuperaPasswordCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<RecuperaPasswordResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RecuperaPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRecuperaPassword(_response);
      });
  }

  protected processRecuperaPassword(
    response: AxiosResponse
  ): Promise<RecuperaPasswordResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RecuperaPasswordResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<RecuperaPasswordResponse>(<any>null);
  }

  ping(cancelToken?: CancelToken | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Ping";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "HEAD",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPing(_response);
      });
  }

  protected processPing(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  createUser(
    command: CreateUsuarioCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<CreateUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/CreateUser";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateUser(_response);
      });
  }

  protected processCreateUser(
    response: AxiosResponse
  ): Promise<CreateUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = CreateUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CreateUsuarioResponse>(<any>null);
  }

  reenviar(
    command: ReenviarEmailCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ReenviarEmailResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Reenviar";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReenviar(_response);
      });
  }

  protected processReenviar(
    response: AxiosResponse
  ): Promise<ReenviarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ReenviarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ReenviarEmailResponse>(<any>null);
  }
}

export interface IEnfermedadClient {
  getEnfermedades(): Promise<GetEnfermedadesResponse>;
  delete(id: number): Promise<DeleteEnfermedadResponse>;
}

export class EnfermedadClient implements IEnfermedadClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getEnfermedades(
    cancelToken?: CancelToken | undefined
  ): Promise<GetEnfermedadesResponse> {
    let url_ = this.baseUrl + "/api/Enfermedad/GetEnfermedades";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEnfermedades(_response);
      });
  }

  protected processGetEnfermedades(
    response: AxiosResponse
  ): Promise<GetEnfermedadesResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetEnfermedadesResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetEnfermedadesResponse>(<any>null);
  }

  delete(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<DeleteEnfermedadResponse> {
    let url_ = this.baseUrl + "/api/Enfermedad/Delete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(
    response: AxiosResponse
  ): Promise<DeleteEnfermedadResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeleteEnfermedadResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DeleteEnfermedadResponse>(<any>null);
  }
}

export interface IEtapaFenologicaClient {
  getAllEtapas(): Promise<GetEtapaFenologicaListResponse>;
  delete(id: number): Promise<DeleteEtapaFenologicaResponse>;
}

export class EtapaFenologicaClient implements IEtapaFenologicaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getAllEtapas(
    cancelToken?: CancelToken | undefined
  ): Promise<GetEtapaFenologicaListResponse> {
    let url_ = this.baseUrl + "/api/EtapaFenologica/GetAllEtapas";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllEtapas(_response);
      });
  }

  protected processGetAllEtapas(
    response: AxiosResponse
  ): Promise<GetEtapaFenologicaListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetEtapaFenologicaListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetEtapaFenologicaListResponse>(<any>null);
  }

  delete(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<DeleteEtapaFenologicaResponse> {
    let url_ = this.baseUrl + "/api/EtapaFenologica/Delete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(
    response: AxiosResponse
  ): Promise<DeleteEtapaFenologicaResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeleteEtapaFenologicaResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DeleteEtapaFenologicaResponse>(<any>null);
  }
}

export interface IPlagaClient {
  getPlagas(): Promise<GetPlagasResponse>;
  delete(id: number): Promise<DeletePlagaResponse>;
}

export class PlagaClient implements IPlagaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getPlagas(cancelToken?: CancelToken | undefined): Promise<GetPlagasResponse> {
    let url_ = this.baseUrl + "/api/Plaga/GetPlagas";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlagas(_response);
      });
  }

  protected processGetPlagas(
    response: AxiosResponse
  ): Promise<GetPlagasResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetPlagasResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetPlagasResponse>(<any>null);
  }

  delete(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<DeletePlagaResponse> {
    let url_ = this.baseUrl + "/api/Plaga/Delete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(
    response: AxiosResponse
  ): Promise<DeletePlagaResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeletePlagaResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DeletePlagaResponse>(<any>null);
  }
}

export interface IUsuariosClient {
  getAll(): Promise<GetUsuariosListResponse>;
  get(id: number): Promise<GetUsuarioDetailResponse>;
  aproveUser(nombreUsuario: string | null): Promise<AproveUsuarioResponse>;
  deleteUser(nombreUsuario: string | null): Promise<DeleteUsuarioResponse>;
  modificarDatos(
    command: ModificarDatosUsuarioCommand
  ): Promise<ModificarDatosUsuarioResponse>;
  modificarEmail(
    command: ModificarEmailCommand
  ): Promise<ModificarEmailResponse>;
  modificarPassword(
    command: ModificarPasswordCommand
  ): Promise<ModificarPasswordResponse>;
  imagenPerfil(
    command: AgregarImagenPerfilCommand
  ): Promise<AgregarImagenPerfilResponse>;
  getImagenPerfil(
    nombreUsuario: string | null,
    size: MySize | undefined
  ): Promise<void>;
}

export class UsuariosClient implements IUsuariosClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getAll(
    cancelToken?: CancelToken | undefined
  ): Promise<GetUsuariosListResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<GetUsuariosListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUsuariosListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUsuariosListResponse>(<any>null);
  }

  get(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetUsuarioDetailResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/Get/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(
    response: AxiosResponse
  ): Promise<GetUsuarioDetailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUsuarioDetailResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUsuarioDetailResponse>(<any>null);
  }

  aproveUser(
    nombreUsuario: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<AproveUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/AproveUser/{nombreUsuario}";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAproveUser(_response);
      });
  }

  protected processAproveUser(
    response: AxiosResponse
  ): Promise<AproveUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AproveUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AproveUsuarioResponse>(<any>null);
  }

  deleteUser(
    nombreUsuario: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<DeleteUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/DeleteUser/{nombreUsuario}";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteUser(_response);
      });
  }

  protected processDeleteUser(
    response: AxiosResponse
  ): Promise<DeleteUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeleteUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DeleteUsuarioResponse>(<any>null);
  }

  modificarDatos(
    command: ModificarDatosUsuarioCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarDatosUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarDatos";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarDatos(_response);
      });
  }

  protected processModificarDatos(
    response: AxiosResponse
  ): Promise<ModificarDatosUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarDatosUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarDatosUsuarioResponse>(<any>null);
  }

  modificarEmail(
    command: ModificarEmailCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarEmailResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarEmail(_response);
      });
  }

  protected processModificarEmail(
    response: AxiosResponse
  ): Promise<ModificarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarEmailResponse>(<any>null);
  }

  modificarPassword(
    command: ModificarPasswordCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarPasswordResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarPassword(_response);
      });
  }

  protected processModificarPassword(
    response: AxiosResponse
  ): Promise<ModificarPasswordResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarPasswordResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarPasswordResponse>(<any>null);
  }

  imagenPerfil(
    command: AgregarImagenPerfilCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarImagenPerfilResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ImagenPerfil";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processImagenPerfil(_response);
      });
  }

  protected processImagenPerfil(
    response: AxiosResponse
  ): Promise<AgregarImagenPerfilResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarImagenPerfilResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarImagenPerfilResponse>(<any>null);
  }

  getImagenPerfil(
    nombreUsuario: string | null,
    size: MySize | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Usuarios/GetImagenPerfil/{nombreUsuario}?";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    if (size === null) throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetImagenPerfil(_response);
      });
  }

  protected processGetImagenPerfil(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = ProblemDetails.fromJS(resultData401);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result401
      );
    } else {
      const _responseText = response.data;
      let resultdefault: any = null;
      let resultDatadefault = _responseText;
      resultdefault = ProblemDetails.fromJS(resultDatadefault);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        resultdefault
      );
    }
  }
}

export class AgregarReporteResponse {
  id!: number;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): AgregarReporteResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarReporteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }
}

export class AgregarReporteCommand {
  reportes!: ReporteDTO[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["reportes"])) {
        this.reportes = [] as any;
        for (let item of _data["reportes"])
          this.reportes!.push(ReporteDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AgregarReporteCommand {
    data = typeof data === "object" ? data : {};
    let result = new AgregarReporteCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.reportes)) {
      data["reportes"] = [];
      for (let item of this.reportes) data["reportes"].push(item.toJSON());
    }
    return data;
  }
}

export class ReporteDTO {
  id!: number;
  lugar!: string | undefined;
  productor!: string | undefined;
  latitude!: number;
  longitud!: number;
  ubicacion!: string | undefined;
  predio!: string | undefined;
  cultivo!: string | undefined;
  etapaFenologica!: string | undefined;
  observaciones!: string | undefined;
  litros!: number;
  enfermedades!: EnfermedadDTO[] | undefined;
  plagas!: PlagaDTO[] | undefined;
  productos!: ProductoDTO[] | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.lugar = _data["lugar"];
      this.productor = _data["productor"];
      this.latitude = _data["latitude"];
      this.longitud = _data["longitud"];
      this.ubicacion = _data["ubicacion"];
      this.predio = _data["predio"];
      this.cultivo = _data["cultivo"];
      this.etapaFenologica = _data["etapaFenologica"];
      this.observaciones = _data["observaciones"];
      this.litros = _data["litros"];
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadDTO.fromJS(item));
      }
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaDTO.fromJS(item));
      }
      if (Array.isArray(_data["productos"])) {
        this.productos = [] as any;
        for (let item of _data["productos"])
          this.productos!.push(ProductoDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ReporteDTO {
    data = typeof data === "object" ? data : {};
    let result = new ReporteDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["lugar"] = this.lugar;
    data["productor"] = this.productor;
    data["latitude"] = this.latitude;
    data["longitud"] = this.longitud;
    data["ubicacion"] = this.ubicacion;
    data["predio"] = this.predio;
    data["cultivo"] = this.cultivo;
    data["etapaFenologica"] = this.etapaFenologica;
    data["observaciones"] = this.observaciones;
    data["litros"] = this.litros;
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    if (Array.isArray(this.productos)) {
      data["productos"] = [];
      for (let item of this.productos) data["productos"].push(item.toJSON());
    }
    return data;
  }
}

export class EnfermedadDTO {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): EnfermedadDTO {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class PlagaDTO {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): PlagaDTO {
    data = typeof data === "object" ? data : {};
    let result = new PlagaDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class ProductoDTO {
  cantidad!: number;
  unidad!: string | undefined;
  nombre!: string | undefined;
  ingredienteActivo!: string | undefined;
  concentracion!: string | undefined;
  intervaloSeguridad!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.cantidad = _data["cantidad"];
      this.unidad = _data["unidad"];
      this.nombre = _data["nombre"];
      this.ingredienteActivo = _data["ingredienteActivo"];
      this.concentracion = _data["concentracion"];
      this.intervaloSeguridad = _data["intervaloSeguridad"];
    }
  }

  static fromJS(data: any): ProductoDTO {
    data = typeof data === "object" ? data : {};
    let result = new ProductoDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["cantidad"] = this.cantidad;
    data["unidad"] = this.unidad;
    data["nombre"] = this.nombre;
    data["ingredienteActivo"] = this.ingredienteActivo;
    data["concentracion"] = this.concentracion;
    data["intervaloSeguridad"] = this.intervaloSeguridad;
    return data;
  }
}

export class GetReporteResponse {
  idReport!: number;
  lugar!: string | undefined;
  created!: Date;
  productor!: string | undefined;
  latitude!: number;
  longitud!: number;
  ubicacion!: string | undefined;
  predio!: string | undefined;
  cultivo!: string | undefined;
  etapaFenologica!: string | undefined;
  observaciones!: string | undefined;
  litros!: number;
  enfermedades!: EnfermedadDTO2[] | undefined;
  plagas!: PlagaDTO2[] | undefined;
  productos!: ProductoDTO2[] | undefined;

  init(_data?: any) {
    if (_data) {
      this.idReport = _data["idReport"];
      this.lugar = _data["lugar"];
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>undefined;
      this.productor = _data["productor"];
      this.latitude = _data["latitude"];
      this.longitud = _data["longitud"];
      this.ubicacion = _data["ubicacion"];
      this.predio = _data["predio"];
      this.cultivo = _data["cultivo"];
      this.etapaFenologica = _data["etapaFenologica"];
      this.observaciones = _data["observaciones"];
      this.litros = _data["litros"];
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadDTO2.fromJS(item));
      }
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaDTO2.fromJS(item));
      }
      if (Array.isArray(_data["productos"])) {
        this.productos = [] as any;
        for (let item of _data["productos"])
          this.productos!.push(ProductoDTO2.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetReporteResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetReporteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idReport"] = this.idReport;
    data["lugar"] = this.lugar;
    data["created"] = this.created
      ? this.created.toISOString()
      : <any>undefined;
    data["productor"] = this.productor;
    data["latitude"] = this.latitude;
    data["longitud"] = this.longitud;
    data["ubicacion"] = this.ubicacion;
    data["predio"] = this.predio;
    data["cultivo"] = this.cultivo;
    data["etapaFenologica"] = this.etapaFenologica;
    data["observaciones"] = this.observaciones;
    data["litros"] = this.litros;
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    if (Array.isArray(this.productos)) {
      data["productos"] = [];
      for (let item of this.productos) data["productos"].push(item.toJSON());
    }
    return data;
  }
}

export class EnfermedadDTO2 {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): EnfermedadDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class PlagaDTO2 {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): PlagaDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new PlagaDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class ProductoDTO2 {
  cantidad!: number;
  nombre!: string | undefined;
  ingredienteActivo!: string | undefined;
  concentracion!: string | undefined;
  intervaloSeguridad!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.cantidad = _data["cantidad"];
      this.nombre = _data["nombre"];
      this.ingredienteActivo = _data["ingredienteActivo"];
      this.concentracion = _data["concentracion"];
      this.intervaloSeguridad = _data["intervaloSeguridad"];
    }
  }

  static fromJS(data: any): ProductoDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new ProductoDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["cantidad"] = this.cantidad;
    data["nombre"] = this.nombre;
    data["ingredienteActivo"] = this.ingredienteActivo;
    data["concentracion"] = this.concentracion;
    data["intervaloSeguridad"] = this.intervaloSeguridad;
    return data;
  }
}

export class ProblemDetails {
  type!: string | undefined;
  title!: string | undefined;
  status!: number | undefined;
  detail!: string | undefined;
  instance!: string | undefined;
  extensions!: { [key: string]: any } | undefined;

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.title = _data["title"];
      this.status = _data["status"];
      this.detail = _data["detail"];
      this.instance = _data["instance"];
      if (_data["extensions"]) {
        this.extensions = {} as any;
        for (let key in _data["extensions"]) {
          if (_data["extensions"].hasOwnProperty(key))
            this.extensions![key] = _data["extensions"][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === "object" ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    data["title"] = this.title;
    data["status"] = this.status;
    data["detail"] = this.detail;
    data["instance"] = this.instance;
    if (this.extensions) {
      data["extensions"] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          data["extensions"][key] = this.extensions[key];
      }
    }
    return data;
  }
}

export class GetSearchReportListResponse {
  busqueda!: DataSearch[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["busqueda"])) {
        this.busqueda = [] as any;
        for (let item of _data["busqueda"])
          this.busqueda!.push(DataSearch.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetSearchReportListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetSearchReportListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.busqueda)) {
      data["busqueda"] = [];
      for (let item of this.busqueda) data["busqueda"].push(item.toJSON());
    }
    return data;
  }
}

export class DataSearch {
  idReport!: number;
  productor!: string | undefined;
  lugar!: string | undefined;
  predio!: string | undefined;
  ubicacion!: string | undefined;
  fecha!: Date;

  init(_data?: any) {
    if (_data) {
      this.idReport = _data["idReport"];
      this.productor = _data["productor"];
      this.lugar = _data["lugar"];
      this.predio = _data["predio"];
      this.ubicacion = _data["ubicacion"];
      this.fecha = _data["fecha"]
        ? new Date(_data["fecha"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): DataSearch {
    data = typeof data === "object" ? data : {};
    let result = new DataSearch();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idReport"] = this.idReport;
    data["productor"] = this.productor;
    data["lugar"] = this.lugar;
    data["predio"] = this.predio;
    data["ubicacion"] = this.ubicacion;
    data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
    return data;
  }
}

export class AgregarArchivoResponse {
  hash!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.hash = _data["hash"];
    }
  }

  static fromJS(data: any): AgregarArchivoResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarArchivoResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["hash"] = this.hash;
    return data;
  }
}

export class TokenDescargaResponse {
  tokenDescarga!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.tokenDescarga = _data["tokenDescarga"];
    }
  }

  static fromJS(data: any): TokenDescargaResponse {
    data = typeof data === "object" ? data : {};
    let result = new TokenDescargaResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tokenDescarga"] = this.tokenDescarga;
    return data;
  }
}

export class TokenDescargaQuery {
  hashArchivo!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.hashArchivo = _data["hashArchivo"];
    }
  }

  static fromJS(data: any): TokenDescargaQuery {
    data = typeof data === "object" ? data : {};
    let result = new TokenDescargaQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["hashArchivo"] = this.hashArchivo;
    return data;
  }
}

export class ConfirmarEmailResponse {
  init(_data?: any) {}

  static fromJS(data: any): ConfirmarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ConfirmarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class IngresarResponse {
  user!: UserInfo | undefined;
  token!: string | undefined;
  refreshToken!: string | undefined;
  expirationDate!: Date;

  init(_data?: any) {
    if (_data) {
      this.user = _data["user"]
        ? UserInfo.fromJS(_data["user"])
        : <any>undefined;
      this.token = _data["token"];
      this.refreshToken = _data["refreshToken"];
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): IngresarResponse {
    data = typeof data === "object" ? data : {};
    let result = new IngresarResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["token"] = this.token;
    data["refreshToken"] = this.refreshToken;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>undefined;
    return data;
  }
}

export class UserInfo {
  idUsuario!: number;
  nombreUsuario!: string | undefined;
  email!: string | undefined;
  tipoUsuario!: TiposUsuario;
  refreshToken!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.idUsuario = _data["idUsuario"];
      this.nombreUsuario = _data["nombreUsuario"];
      this.email = _data["email"];
      this.tipoUsuario = _data["tipoUsuario"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): UserInfo {
    data = typeof data === "object" ? data : {};
    let result = new UserInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] = this.idUsuario;
    data["nombreUsuario"] = this.nombreUsuario;
    data["email"] = this.email;
    data["tipoUsuario"] = this.tipoUsuario;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export enum TiposUsuario {
  Admin = 1,
  User = 2,
  Productor = 3,
  Visor = 4,
}

export class GetUsuarioLoginQuery {
  nombreUsuario!: string | undefined;
  password!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.nombreUsuario = _data["nombreUsuario"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): GetUsuarioLoginQuery {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuarioLoginQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nombreUsuario"] = this.nombreUsuario;
    data["password"] = this.password;
    return data;
  }
}

export class RefreshCredentialsCommand {
  refreshToken!: string | undefined;
  token!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data["refreshToken"];
      this.token = _data["token"];
    }
  }

  static fromJS(data: any): RefreshCredentialsCommand {
    data = typeof data === "object" ? data : {};
    let result = new RefreshCredentialsCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] = this.refreshToken;
    data["token"] = this.token;
    return data;
  }
}

export class InvalidaTokenResponse {
  init(_data?: any) {}

  static fromJS(data: any): InvalidaTokenResponse {
    data = typeof data === "object" ? data : {};
    let result = new InvalidaTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class InvalidaTokenCommand {
  refreshToken!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): InvalidaTokenCommand {
    data = typeof data === "object" ? data : {};
    let result = new InvalidaTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export class RecuperaPasswordGeneraTokenResponse {
  init(_data?: any) {}

  static fromJS(data: any): RecuperaPasswordGeneraTokenResponse {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordGeneraTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class RecuperaPasswordGeneraTokenCommand {
  email!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): RecuperaPasswordGeneraTokenCommand {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordGeneraTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    return data;
  }
}

export class RecuperaPasswordResponse {
  init(_data?: any) {}

  static fromJS(data: any): RecuperaPasswordResponse {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class RecuperaPasswordCommand {
  token!: string | undefined;
  password!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): RecuperaPasswordCommand {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token;
    data["password"] = this.password;
    return data;
  }
}

export abstract class NotificationResponse {
  notificationMessage!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.notificationMessage = _data["notificationMessage"];
    }
  }

  static fromJS(data: any): NotificationResponse {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'NotificationResponse' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["notificationMessage"] = this.notificationMessage;
    return data;
  }
}

export class CreateUsuarioResponse extends NotificationResponse {
  id!: number;
  email!: string | undefined;
  nombreUsuario!: string | undefined;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.email = _data["email"];
      this.nombreUsuario = _data["nombreUsuario"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
    }
  }

  static fromJS(data: any): CreateUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new CreateUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["email"] = this.email;
    data["nombreUsuario"] = this.nombreUsuario;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    super.toJSON(data);
    return data;
  }
}

export class CreateUsuarioCommand {
  nombreUsuario!: string | undefined;
  email!: string | undefined;
  password!: string | undefined;
  tipoUsuario!: number;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.nombreUsuario = _data["nombreUsuario"];
      this.email = _data["email"];
      this.password = _data["password"];
      this.tipoUsuario = _data["tipoUsuario"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
    }
  }

  static fromJS(data: any): CreateUsuarioCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateUsuarioCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nombreUsuario"] = this.nombreUsuario;
    data["email"] = this.email;
    data["password"] = this.password;
    data["tipoUsuario"] = this.tipoUsuario;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    return data;
  }
}

export class ReenviarEmailResponse extends NotificationResponse {
  email!: string | undefined;
  confirmado!: boolean;
  tipoUsuario!: TiposUsuario;
  token!: string | undefined;

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.email = _data["email"];
      this.confirmado = _data["confirmado"];
      this.tipoUsuario = _data["tipoUsuario"];
      this.token = _data["token"];
    }
  }

  static fromJS(data: any): ReenviarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ReenviarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    data["confirmado"] = this.confirmado;
    data["tipoUsuario"] = this.tipoUsuario;
    data["token"] = this.token;
    super.toJSON(data);
    return data;
  }
}

export class ReenviarEmailCommand {
  email!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ReenviarEmailCommand {
    data = typeof data === "object" ? data : {};
    let result = new ReenviarEmailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    return data;
  }
}

export class GetEnfermedadesResponse {
  enfermedades!: EnfermedadLookupModel[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEnfermedadesResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetEnfermedadesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    return data;
  }
}

export class EnfermedadLookupModel {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): EnfermedadLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class DeleteEnfermedadResponse {
  init(_data?: any) {}

  static fromJS(data: any): DeleteEnfermedadResponse {
    data = typeof data === "object" ? data : {};
    let result = new DeleteEnfermedadResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class GetEtapaFenologicaListResponse {
  etapas!: EtapaLookUpModel[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["etapas"])) {
        this.etapas = [] as any;
        for (let item of _data["etapas"])
          this.etapas!.push(EtapaLookUpModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEtapaFenologicaListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetEtapaFenologicaListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.etapas)) {
      data["etapas"] = [];
      for (let item of this.etapas) data["etapas"].push(item.toJSON());
    }
    return data;
  }
}

export class EtapaLookUpModel {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): EtapaLookUpModel {
    data = typeof data === "object" ? data : {};
    let result = new EtapaLookUpModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class DeleteEtapaFenologicaResponse {
  init(_data?: any) {}

  static fromJS(data: any): DeleteEtapaFenologicaResponse {
    data = typeof data === "object" ? data : {};
    let result = new DeleteEtapaFenologicaResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class GetPlagasResponse {
  plagas!: PlagaLookupModel[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetPlagasResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetPlagasResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    return data;
  }
}

export class PlagaLookupModel {
  id!: number;
  nombre!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombre = _data["nombre"];
    }
  }

  static fromJS(data: any): PlagaLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new PlagaLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombre"] = this.nombre;
    return data;
  }
}

export class DeletePlagaResponse {
  init(_data?: any) {}

  static fromJS(data: any): DeletePlagaResponse {
    data = typeof data === "object" ? data : {};
    let result = new DeletePlagaResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class GetUsuariosListResponse {
  usuarios!: UsuarioLookupModel[] | undefined;

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["usuarios"])) {
        this.usuarios = [] as any;
        for (let item of _data["usuarios"])
          this.usuarios!.push(UsuarioLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetUsuariosListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuariosListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.usuarios)) {
      data["usuarios"] = [];
      for (let item of this.usuarios) data["usuarios"].push(item.toJSON());
    }
    return data;
  }
}

export class UsuarioLookupModel {
  id!: number;
  nombreUsuario!: string | undefined;
  email!: string | undefined;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;
  tipoUsuario!: TiposUsuario;
  confirmado!: boolean;

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nombreUsuario = _data["nombreUsuario"];
      this.email = _data["email"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
      this.tipoUsuario = _data["tipoUsuario"];
      this.confirmado = _data["confirmado"];
    }
  }

  static fromJS(data: any): UsuarioLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new UsuarioLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nombreUsuario"] = this.nombreUsuario;
    data["email"] = this.email;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    data["tipoUsuario"] = this.tipoUsuario;
    data["confirmado"] = this.confirmado;
    return data;
  }
}

export class GetUsuarioDetailResponse {
  idUsuario!: number;
  nombreUsuario!: string | undefined;
  email!: string | undefined;
  tipoUsuario!: TiposUsuario;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.idUsuario = _data["idUsuario"];
      this.nombreUsuario = _data["nombreUsuario"];
      this.email = _data["email"];
      this.tipoUsuario = _data["tipoUsuario"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
    }
  }

  static fromJS(data: any): GetUsuarioDetailResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuarioDetailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] = this.idUsuario;
    data["nombreUsuario"] = this.nombreUsuario;
    data["email"] = this.email;
    data["tipoUsuario"] = this.tipoUsuario;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    return data;
  }
}

export class AproveUsuarioResponse {
  init(_data?: any) {}

  static fromJS(data: any): AproveUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new AproveUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class DeleteUsuarioResponse {
  init(_data?: any) {}

  static fromJS(data: any): DeleteUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new DeleteUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class ModificarDatosUsuarioResponse {
  idUsuario!: number;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.idUsuario = _data["idUsuario"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
    }
  }

  static fromJS(data: any): ModificarDatosUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarDatosUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] = this.idUsuario;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    return data;
  }
}

export class ModificarDatosUsuarioCommand {
  idUsuario!: number;
  nombre!: string | undefined;
  apellidoPaterno!: string | undefined;
  apellidoMaterno!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.idUsuario = _data["idUsuario"];
      this.nombre = _data["nombre"];
      this.apellidoPaterno = _data["apellidoPaterno"];
      this.apellidoMaterno = _data["apellidoMaterno"];
    }
  }

  static fromJS(data: any): ModificarDatosUsuarioCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarDatosUsuarioCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] = this.idUsuario;
    data["nombre"] = this.nombre;
    data["apellidoPaterno"] = this.apellidoPaterno;
    data["apellidoMaterno"] = this.apellidoMaterno;
    return data;
  }
}

export class ModificarEmailResponse {
  email!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ModificarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    return data;
  }
}

export class ModificarEmailCommand {
  nuevoEmail!: string | undefined;
  password!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.nuevoEmail = _data["nuevoEmail"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): ModificarEmailCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarEmailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nuevoEmail"] = this.nuevoEmail;
    data["password"] = this.password;
    return data;
  }
}

export class ModificarPasswordResponse extends NotificationResponse {
  email!: string | undefined;

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ModificarPasswordResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarPasswordResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    super.toJSON(data);
    return data;
  }
}

export class ModificarPasswordCommand {
  passwordActual!: string | undefined;
  passwordNuevo!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.passwordActual = _data["passwordActual"];
      this.passwordNuevo = _data["passwordNuevo"];
    }
  }

  static fromJS(data: any): ModificarPasswordCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["passwordActual"] = this.passwordActual;
    data["passwordNuevo"] = this.passwordNuevo;
    return data;
  }
}

export class AgregarImagenPerfilResponse {
  init(_data?: any) {}

  static fromJS(data: any): AgregarImagenPerfilResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarImagenPerfilResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export class AgregarImagenPerfilCommand {
  imagen!: string | undefined;

  init(_data?: any) {
    if (_data) {
      this.imagen = _data["imagen"];
    }
  }

  static fromJS(data: any): AgregarImagenPerfilCommand {
    data = typeof data === "object" ? data : {};
    let result = new AgregarImagenPerfilCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["imagen"] = this.imagen;
    return data;
  }
}

export enum MySize {
  Small = 0,
  Medium = 1,
  Large = 2,
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
