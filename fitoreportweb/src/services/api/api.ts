/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

export class ReporteClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  agregar(
    command: AgregarReporteCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarReporteResponse> {
    let url_ = this.baseUrl + "/api/Reporte";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAgregar(_response);
      });
  }

  protected processAgregar(
    response: AxiosResponse
  ): Promise<AgregarReporteResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarReporteResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarReporteResponse>(<any>null);
  }

  getSearchList(
    cancelToken?: CancelToken | undefined
  ): Promise<GetSearchReportListResponse> {
    let url_ = this.baseUrl + "/api/Reporte";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSearchList(_response);
      });
  }

  protected processGetSearchList(
    response: AxiosResponse
  ): Promise<GetSearchReportListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetSearchReportListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetSearchReportListResponse>(<any>null);
  }

  get(
    idReport: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetReporteResponse> {
    let url_ = this.baseUrl + "/api/Reporte/{idReport}";
    if (idReport === undefined || idReport === null)
      throw new Error("The parameter 'idReport' must be defined.");
    url_ = url_.replace("{idReport}", encodeURIComponent("" + idReport));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(response: AxiosResponse): Promise<GetReporteResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetReporteResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetReporteResponse>(<any>null);
  }
}

export class ArchivosClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  agregarArchivo(
    command: FileParameter | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarArchivoResponse> {
    let url_ = this.baseUrl + "/api/Archivos/AgregarArchivo";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (command !== null && command !== undefined)
      content_.append(
        "command",
        command.data,
        command.fileName ? command.fileName : "command"
      );

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAgregarArchivo(_response);
      });
  }

  protected processAgregarArchivo(
    response: AxiosResponse
  ): Promise<AgregarArchivoResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarArchivoResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarArchivoResponse>(<any>null);
  }

  generaTokenDescarga(
    query: TokenDescargaQuery,
    cancelToken?: CancelToken | undefined
  ): Promise<TokenDescargaResponse> {
    let url_ = this.baseUrl + "/api/Archivos/GeneraTokenDescarga";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGeneraTokenDescarga(_response);
      });
  }

  protected processGeneraTokenDescarga(
    response: AxiosResponse
  ): Promise<TokenDescargaResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = TokenDescargaResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TokenDescargaResponse>(<any>null);
  }

  descargarArchivo(
    hash: string | null,
    token: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/Archivos/DescargarArchivo/{hash}?";
    if (hash === undefined || hash === null)
      throw new Error("The parameter 'hash' must be defined.");
    url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
    if (token !== undefined && token !== null)
      url_ += "token=" + encodeURIComponent("" + token) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDescargarArchivo(_response);
      });
  }

  protected processDescargarArchivo(
    response: AxiosResponse
  ): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileResponse>(<any>null);
  }
}

export class CuentaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  confirmar(
    token: string | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ConfirmarEmailResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Confirmar?";
    if (token !== undefined && token !== null)
      url_ += "Token=" + encodeURIComponent("" + token) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processConfirmar(_response);
      });
  }

  protected processConfirmar(
    response: AxiosResponse
  ): Promise<ConfirmarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ConfirmarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ConfirmarEmailResponse>(<any>null);
  }

  ingresar(
    query: GetUsuarioLoginQuery,
    cancelToken?: CancelToken | undefined
  ): Promise<IngresarResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Ingresar";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processIngresar(_response);
      });
  }

  protected processIngresar(
    response: AxiosResponse
  ): Promise<IngresarResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IngresarResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<IngresarResponse>(<any>null);
  }

  refreshCredentials(
    query: RefreshCredentialsCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<IngresarResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RefreshCredentials";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRefreshCredentials(_response);
      });
  }

  protected processRefreshCredentials(
    response: AxiosResponse
  ): Promise<IngresarResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IngresarResponse.fromJS(resultData200);
      return result200;
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ProblemDetails.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else {
      const _responseText = response.data;
      let resultdefault: any = null;
      let resultDatadefault = _responseText;
      resultdefault = ProblemDetails.fromJS(resultDatadefault);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        resultdefault
      );
    }
  }

  invalidaToken(
    query: InvalidaTokenCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<InvalidaTokenResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/InvalidaToken";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processInvalidaToken(_response);
      });
  }

  protected processInvalidaToken(
    response: AxiosResponse
  ): Promise<InvalidaTokenResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = InvalidaTokenResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<InvalidaTokenResponse>(<any>null);
  }

  recuperaPasswordGeneraToken(
    query: RecuperaPasswordGeneraTokenCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<RecuperaPasswordGeneraTokenResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RecuperaPasswordGeneraToken";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRecuperaPasswordGeneraToken(_response);
      });
  }

  protected processRecuperaPasswordGeneraToken(
    response: AxiosResponse
  ): Promise<RecuperaPasswordGeneraTokenResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RecuperaPasswordGeneraTokenResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<RecuperaPasswordGeneraTokenResponse>(<any>null);
  }

  recuperaPassword(
    query: RecuperaPasswordCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<RecuperaPasswordResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/RecuperaPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(query);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRecuperaPassword(_response);
      });
  }

  protected processRecuperaPassword(
    response: AxiosResponse
  ): Promise<RecuperaPasswordResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RecuperaPasswordResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<RecuperaPasswordResponse>(<any>null);
  }

  ping(cancelToken?: CancelToken | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Ping";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "HEAD",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPing(_response);
      });
  }

  protected processPing(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve({
        fileName: fileName,
        status: status,
        data: response.data as Blob,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  createUser(
    command: CreateUsuarioCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<CreateUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/CreateUser";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateUser(_response);
      });
  }

  protected processCreateUser(
    response: AxiosResponse
  ): Promise<CreateUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = CreateUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CreateUsuarioResponse>(<any>null);
  }

  reenviar(
    command: ReenviarEmailCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ReenviarEmailResponse> {
    let url_ = this.baseUrl + "/api/Cuenta/Reenviar";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReenviar(_response);
      });
  }

  protected processReenviar(
    response: AxiosResponse
  ): Promise<ReenviarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ReenviarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ReenviarEmailResponse>(<any>null);
  }
}

export class EnfermedadClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getEnfermedades(
    cancelToken?: CancelToken | undefined
  ): Promise<GetEnfermedadesResponse> {
    let url_ = this.baseUrl + "/api/Enfermedad";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEnfermedades(_response);
      });
  }

  protected processGetEnfermedades(
    response: AxiosResponse
  ): Promise<GetEnfermedadesResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetEnfermedadesResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetEnfermedadesResponse>(<any>null);
  }
}

export class EtapaFenologicaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getAllEtapas(
    cancelToken?: CancelToken | undefined
  ): Promise<GetEtapaFenologicaListResponse> {
    let url_ = this.baseUrl + "/api/EtapaFenologica";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllEtapas(_response);
      });
  }

  protected processGetAllEtapas(
    response: AxiosResponse
  ): Promise<GetEtapaFenologicaListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetEtapaFenologicaListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetEtapaFenologicaListResponse>(<any>null);
  }
}

export class PlagaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getPlagas(cancelToken?: CancelToken | undefined): Promise<GetPlagasResponse> {
    let url_ = this.baseUrl + "/api/Plaga";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPlagas(_response);
      });
  }

  protected processGetPlagas(
    response: AxiosResponse
  ): Promise<GetPlagasResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetPlagasResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetPlagasResponse>(<any>null);
  }
}

export class UsuariosClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:5001";
  }

  getAll(
    cancelToken?: CancelToken | undefined
  ): Promise<GetUsuariosListResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<GetUsuariosListResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUsuariosListResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUsuariosListResponse>(<any>null);
  }

  get(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetUsuarioDetailResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/Get/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGet(_response);
      });
  }

  protected processGet(
    response: AxiosResponse
  ): Promise<GetUsuarioDetailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUsuarioDetailResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUsuarioDetailResponse>(<any>null);
  }

  aproveUser(
    nombreUsuario: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<AproveUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/AproveUser/{nombreUsuario}";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAproveUser(_response);
      });
  }

  protected processAproveUser(
    response: AxiosResponse
  ): Promise<AproveUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AproveUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AproveUsuarioResponse>(<any>null);
  }

  deleteUser(
    nombreUsuario: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<DeleteUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/DeleteUser/{nombreUsuario}";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteUser(_response);
      });
  }

  protected processDeleteUser(
    response: AxiosResponse
  ): Promise<DeleteUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DeleteUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result404
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DeleteUsuarioResponse>(<any>null);
  }

  modificarDatos(
    command: ModificarDatosUsuarioCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarDatosUsuarioResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarDatos";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarDatos(_response);
      });
  }

  protected processModificarDatos(
    response: AxiosResponse
  ): Promise<ModificarDatosUsuarioResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarDatosUsuarioResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarDatosUsuarioResponse>(<any>null);
  }

  modificarEmail(
    command: ModificarEmailCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarEmailResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarEmail(_response);
      });
  }

  protected processModificarEmail(
    response: AxiosResponse
  ): Promise<ModificarEmailResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarEmailResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarEmailResponse>(<any>null);
  }

  modificarPassword(
    command: ModificarPasswordCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<ModificarPasswordResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ModificarPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processModificarPassword(_response);
      });
  }

  protected processModificarPassword(
    response: AxiosResponse
  ): Promise<ModificarPasswordResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ModificarPasswordResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ModificarPasswordResponse>(<any>null);
  }

  imagenPerfil(
    command: AgregarImagenPerfilCommand,
    cancelToken?: CancelToken | undefined
  ): Promise<AgregarImagenPerfilResponse> {
    let url_ = this.baseUrl + "/api/Usuarios/ImagenPerfil";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(command);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processImagenPerfil(_response);
      });
  }

  protected processImagenPerfil(
    response: AxiosResponse
  ): Promise<AgregarImagenPerfilResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AgregarImagenPerfilResponse.fromJS(resultData200);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AgregarImagenPerfilResponse>(<any>null);
  }

  getImagenPerfil(
    nombreUsuario: string | null,
    size: MySize | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Usuarios/GetImagenPerfil/{nombreUsuario}?";
    if (nombreUsuario === undefined || nombreUsuario === null)
      throw new Error("The parameter 'nombreUsuario' must be defined.");
    url_ = url_.replace(
      "{nombreUsuario}",
      encodeURIComponent("" + nombreUsuario)
    );
    if (size === null) throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetImagenPerfil(_response);
      });
  }

  protected processGetImagenPerfil(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status === 401) {
      const _responseText = response.data;
      let result401: any = null;
      let resultData401 = _responseText;
      result401 = ProblemDetails.fromJS(resultData401);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result401
      );
    } else {
      const _responseText = response.data;
      let resultdefault: any = null;
      let resultDatadefault = _responseText;
      resultdefault = ProblemDetails.fromJS(resultDatadefault);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        resultdefault
      );
    }
  }
}

export class AgregarReporteResponse implements IAgregarReporteResponse {
  id?: number;

  constructor(data?: IAgregarReporteResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
    }
  }

  static fromJS(data: any): AgregarReporteResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarReporteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    return data;
  }
}

export interface IAgregarReporteResponse {
  id?: number;
}

export class AgregarReporteCommand implements IAgregarReporteCommand {
  reportes?: ReporteDTO[] | null;

  constructor(data?: IAgregarReporteCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["reportes"])) {
        this.reportes = [] as any;
        for (let item of _data["reportes"])
          this.reportes!.push(ReporteDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AgregarReporteCommand {
    data = typeof data === "object" ? data : {};
    let result = new AgregarReporteCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.reportes)) {
      data["reportes"] = [];
      for (let item of this.reportes) data["reportes"].push(item.toJSON());
    }
    return data;
  }
}

export interface IAgregarReporteCommand {
  reportes?: ReporteDTO[] | null;
}

export class ReporteDTO implements IReporteDTO {
  id?: number;
  lugar?: string | null;
  productor?: string | null;
  latitude?: number;
  longitud?: number;
  ubicacion?: string | null;
  predio?: string | null;
  cultivo?: string | null;
  etapaFenologica?: string | null;
  observaciones?: string | null;
  litros?: number;
  enfermedades?: EnfermedadDTO[] | null;
  plagas?: PlagaDTO[] | null;
  productos?: ProductoDTO[] | null;

  constructor(data?: IReporteDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.lugar = _data["lugar"] !== undefined ? _data["lugar"] : <any>null;
      this.productor =
        _data["productor"] !== undefined ? _data["productor"] : <any>null;
      this.latitude =
        _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
      this.longitud =
        _data["longitud"] !== undefined ? _data["longitud"] : <any>null;
      this.ubicacion =
        _data["ubicacion"] !== undefined ? _data["ubicacion"] : <any>null;
      this.predio = _data["predio"] !== undefined ? _data["predio"] : <any>null;
      this.cultivo =
        _data["cultivo"] !== undefined ? _data["cultivo"] : <any>null;
      this.etapaFenologica =
        _data["etapaFenologica"] !== undefined
          ? _data["etapaFenologica"]
          : <any>null;
      this.observaciones =
        _data["observaciones"] !== undefined
          ? _data["observaciones"]
          : <any>null;
      this.litros = _data["litros"] !== undefined ? _data["litros"] : <any>null;
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadDTO.fromJS(item));
      }
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaDTO.fromJS(item));
      }
      if (Array.isArray(_data["productos"])) {
        this.productos = [] as any;
        for (let item of _data["productos"])
          this.productos!.push(ProductoDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ReporteDTO {
    data = typeof data === "object" ? data : {};
    let result = new ReporteDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["lugar"] = this.lugar !== undefined ? this.lugar : <any>null;
    data["productor"] =
      this.productor !== undefined ? this.productor : <any>null;
    data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
    data["longitud"] = this.longitud !== undefined ? this.longitud : <any>null;
    data["ubicacion"] =
      this.ubicacion !== undefined ? this.ubicacion : <any>null;
    data["predio"] = this.predio !== undefined ? this.predio : <any>null;
    data["cultivo"] = this.cultivo !== undefined ? this.cultivo : <any>null;
    data["etapaFenologica"] =
      this.etapaFenologica !== undefined ? this.etapaFenologica : <any>null;
    data["observaciones"] =
      this.observaciones !== undefined ? this.observaciones : <any>null;
    data["litros"] = this.litros !== undefined ? this.litros : <any>null;
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    if (Array.isArray(this.productos)) {
      data["productos"] = [];
      for (let item of this.productos) data["productos"].push(item.toJSON());
    }
    return data;
  }
}

export interface IReporteDTO {
  id?: number;
  lugar?: string | null;
  productor?: string | null;
  latitude?: number;
  longitud?: number;
  ubicacion?: string | null;
  predio?: string | null;
  cultivo?: string | null;
  etapaFenologica?: string | null;
  observaciones?: string | null;
  litros?: number;
  enfermedades?: EnfermedadDTO[] | null;
  plagas?: PlagaDTO[] | null;
  productos?: ProductoDTO[] | null;
}

export class EnfermedadDTO implements IEnfermedadDTO {
  id?: number;
  nombre?: string | null;

  constructor(data?: IEnfermedadDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): EnfermedadDTO {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IEnfermedadDTO {
  id?: number;
  nombre?: string | null;
}

export class PlagaDTO implements IPlagaDTO {
  id?: number;
  nombre?: string | null;

  constructor(data?: IPlagaDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): PlagaDTO {
    data = typeof data === "object" ? data : {};
    let result = new PlagaDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IPlagaDTO {
  id?: number;
  nombre?: string | null;
}

export class ProductoDTO implements IProductoDTO {
  cantidad?: number;
  nombre?: string | null;
  ingredienteActivo?: string | null;
  concentracion?: string | null;
  intervaloSeguridad?: string | null;

  constructor(data?: IProductoDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cantidad =
        _data["cantidad"] !== undefined ? _data["cantidad"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.ingredienteActivo =
        _data["ingredienteActivo"] !== undefined
          ? _data["ingredienteActivo"]
          : <any>null;
      this.concentracion =
        _data["concentracion"] !== undefined
          ? _data["concentracion"]
          : <any>null;
      this.intervaloSeguridad =
        _data["intervaloSeguridad"] !== undefined
          ? _data["intervaloSeguridad"]
          : <any>null;
    }
  }

  static fromJS(data: any): ProductoDTO {
    data = typeof data === "object" ? data : {};
    let result = new ProductoDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["cantidad"] = this.cantidad !== undefined ? this.cantidad : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["ingredienteActivo"] =
      this.ingredienteActivo !== undefined ? this.ingredienteActivo : <any>null;
    data["concentracion"] =
      this.concentracion !== undefined ? this.concentracion : <any>null;
    data["intervaloSeguridad"] =
      this.intervaloSeguridad !== undefined
        ? this.intervaloSeguridad
        : <any>null;
    return data;
  }
}

export interface IProductoDTO {
  cantidad?: number;
  nombre?: string | null;
  ingredienteActivo?: string | null;
  concentracion?: string | null;
  intervaloSeguridad?: string | null;
}

export class GetReporteResponse implements IGetReporteResponse {
  idReport?: number;
  lugar?: string | null;
  created?: Date;
  productor?: string | null;
  latitude?: number;
  longitud?: number;
  ubicacion?: string | null;
  predio?: string | null;
  cultivo?: string | null;
  etapaFenologica?: string | null;
  observaciones?: string | null;
  litros?: number;
  enfermedades?: EnfermedadDTO2[] | null;
  plagas?: PlagaDTO2[] | null;
  productos?: ProductoDTO2[] | null;

  constructor(data?: IGetReporteResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idReport =
        _data["idReport"] !== undefined ? _data["idReport"] : <any>null;
      this.lugar = _data["lugar"] !== undefined ? _data["lugar"] : <any>null;
      this.created = _data["created"]
        ? new Date(_data["created"].toString())
        : <any>null;
      this.productor =
        _data["productor"] !== undefined ? _data["productor"] : <any>null;
      this.latitude =
        _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
      this.longitud =
        _data["longitud"] !== undefined ? _data["longitud"] : <any>null;
      this.ubicacion =
        _data["ubicacion"] !== undefined ? _data["ubicacion"] : <any>null;
      this.predio = _data["predio"] !== undefined ? _data["predio"] : <any>null;
      this.cultivo =
        _data["cultivo"] !== undefined ? _data["cultivo"] : <any>null;
      this.etapaFenologica =
        _data["etapaFenologica"] !== undefined
          ? _data["etapaFenologica"]
          : <any>null;
      this.observaciones =
        _data["observaciones"] !== undefined
          ? _data["observaciones"]
          : <any>null;
      this.litros = _data["litros"] !== undefined ? _data["litros"] : <any>null;
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadDTO2.fromJS(item));
      }
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaDTO2.fromJS(item));
      }
      if (Array.isArray(_data["productos"])) {
        this.productos = [] as any;
        for (let item of _data["productos"])
          this.productos!.push(ProductoDTO2.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetReporteResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetReporteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idReport"] = this.idReport !== undefined ? this.idReport : <any>null;
    data["lugar"] = this.lugar !== undefined ? this.lugar : <any>null;
    data["created"] = this.created ? this.created.toISOString() : <any>null;
    data["productor"] =
      this.productor !== undefined ? this.productor : <any>null;
    data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
    data["longitud"] = this.longitud !== undefined ? this.longitud : <any>null;
    data["ubicacion"] =
      this.ubicacion !== undefined ? this.ubicacion : <any>null;
    data["predio"] = this.predio !== undefined ? this.predio : <any>null;
    data["cultivo"] = this.cultivo !== undefined ? this.cultivo : <any>null;
    data["etapaFenologica"] =
      this.etapaFenologica !== undefined ? this.etapaFenologica : <any>null;
    data["observaciones"] =
      this.observaciones !== undefined ? this.observaciones : <any>null;
    data["litros"] = this.litros !== undefined ? this.litros : <any>null;
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    if (Array.isArray(this.productos)) {
      data["productos"] = [];
      for (let item of this.productos) data["productos"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetReporteResponse {
  idReport?: number;
  lugar?: string | null;
  created?: Date;
  productor?: string | null;
  latitude?: number;
  longitud?: number;
  ubicacion?: string | null;
  predio?: string | null;
  cultivo?: string | null;
  etapaFenologica?: string | null;
  observaciones?: string | null;
  litros?: number;
  enfermedades?: EnfermedadDTO2[] | null;
  plagas?: PlagaDTO2[] | null;
  productos?: ProductoDTO2[] | null;
}

export class EnfermedadDTO2 implements IEnfermedadDTO2 {
  id?: number;
  nombre?: string | null;

  constructor(data?: IEnfermedadDTO2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): EnfermedadDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IEnfermedadDTO2 {
  id?: number;
  nombre?: string | null;
}

export class PlagaDTO2 implements IPlagaDTO2 {
  id?: number;
  nombre?: string | null;

  constructor(data?: IPlagaDTO2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): PlagaDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new PlagaDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IPlagaDTO2 {
  id?: number;
  nombre?: string | null;
}

export class ProductoDTO2 implements IProductoDTO2 {
  cantidad?: number;
  nombre?: string | null;
  ingredienteActivo?: string | null;
  concentracion?: string | null;
  intervaloSeguridad?: string | null;

  constructor(data?: IProductoDTO2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cantidad =
        _data["cantidad"] !== undefined ? _data["cantidad"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.ingredienteActivo =
        _data["ingredienteActivo"] !== undefined
          ? _data["ingredienteActivo"]
          : <any>null;
      this.concentracion =
        _data["concentracion"] !== undefined
          ? _data["concentracion"]
          : <any>null;
      this.intervaloSeguridad =
        _data["intervaloSeguridad"] !== undefined
          ? _data["intervaloSeguridad"]
          : <any>null;
    }
  }

  static fromJS(data: any): ProductoDTO2 {
    data = typeof data === "object" ? data : {};
    let result = new ProductoDTO2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["cantidad"] = this.cantidad !== undefined ? this.cantidad : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["ingredienteActivo"] =
      this.ingredienteActivo !== undefined ? this.ingredienteActivo : <any>null;
    data["concentracion"] =
      this.concentracion !== undefined ? this.concentracion : <any>null;
    data["intervaloSeguridad"] =
      this.intervaloSeguridad !== undefined
        ? this.intervaloSeguridad
        : <any>null;
    return data;
  }
}

export interface IProductoDTO2 {
  cantidad?: number;
  nombre?: string | null;
  ingredienteActivo?: string | null;
  concentracion?: string | null;
  intervaloSeguridad?: string | null;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  extensions?: { [key: string]: any } | null;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
      this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
      this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
      this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
      this.instance =
        _data["instance"] !== undefined ? _data["instance"] : <any>null;
      if (_data["extensions"]) {
        this.extensions = {} as any;
        for (let key in _data["extensions"]) {
          if (_data["extensions"].hasOwnProperty(key))
            this.extensions![key] = _data["extensions"][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === "object" ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type !== undefined ? this.type : <any>null;
    data["title"] = this.title !== undefined ? this.title : <any>null;
    data["status"] = this.status !== undefined ? this.status : <any>null;
    data["detail"] = this.detail !== undefined ? this.detail : <any>null;
    data["instance"] = this.instance !== undefined ? this.instance : <any>null;
    if (this.extensions) {
      data["extensions"] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          data["extensions"][key] =
            this.extensions[key] !== undefined
              ? this.extensions[key]
              : <any>null;
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | null;
  title?: string | null;
  status?: number | null;
  detail?: string | null;
  instance?: string | null;
  extensions?: { [key: string]: any } | null;
}

export class GetSearchReportListResponse
  implements IGetSearchReportListResponse {
  busqueda?: DataSearch[] | null;

  constructor(data?: IGetSearchReportListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["busqueda"])) {
        this.busqueda = [] as any;
        for (let item of _data["busqueda"])
          this.busqueda!.push(DataSearch.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetSearchReportListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetSearchReportListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.busqueda)) {
      data["busqueda"] = [];
      for (let item of this.busqueda) data["busqueda"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetSearchReportListResponse {
  busqueda?: DataSearch[] | null;
}

export class DataSearch implements IDataSearch {
  idReport?: number;
  productor?: string | null;
  lugar?: string | null;
  predio?: string | null;
  ubicacion?: string | null;
  fecha?: Date;

  constructor(data?: IDataSearch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idReport =
        _data["idReport"] !== undefined ? _data["idReport"] : <any>null;
      this.productor =
        _data["productor"] !== undefined ? _data["productor"] : <any>null;
      this.lugar = _data["lugar"] !== undefined ? _data["lugar"] : <any>null;
      this.predio = _data["predio"] !== undefined ? _data["predio"] : <any>null;
      this.ubicacion =
        _data["ubicacion"] !== undefined ? _data["ubicacion"] : <any>null;
      this.fecha = _data["fecha"]
        ? new Date(_data["fecha"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): DataSearch {
    data = typeof data === "object" ? data : {};
    let result = new DataSearch();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idReport"] = this.idReport !== undefined ? this.idReport : <any>null;
    data["productor"] =
      this.productor !== undefined ? this.productor : <any>null;
    data["lugar"] = this.lugar !== undefined ? this.lugar : <any>null;
    data["predio"] = this.predio !== undefined ? this.predio : <any>null;
    data["ubicacion"] =
      this.ubicacion !== undefined ? this.ubicacion : <any>null;
    data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>null;
    return data;
  }
}

export interface IDataSearch {
  idReport?: number;
  productor?: string | null;
  lugar?: string | null;
  predio?: string | null;
  ubicacion?: string | null;
  fecha?: Date;
}

export class AgregarArchivoResponse implements IAgregarArchivoResponse {
  hash?: string | null;

  constructor(data?: IAgregarArchivoResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hash = _data["hash"] !== undefined ? _data["hash"] : <any>null;
    }
  }

  static fromJS(data: any): AgregarArchivoResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarArchivoResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["hash"] = this.hash !== undefined ? this.hash : <any>null;
    return data;
  }
}

export interface IAgregarArchivoResponse {
  hash?: string | null;
}

export class TokenDescargaResponse implements ITokenDescargaResponse {
  tokenDescarga?: string | null;

  constructor(data?: ITokenDescargaResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tokenDescarga =
        _data["tokenDescarga"] !== undefined
          ? _data["tokenDescarga"]
          : <any>null;
    }
  }

  static fromJS(data: any): TokenDescargaResponse {
    data = typeof data === "object" ? data : {};
    let result = new TokenDescargaResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tokenDescarga"] =
      this.tokenDescarga !== undefined ? this.tokenDescarga : <any>null;
    return data;
  }
}

export interface ITokenDescargaResponse {
  tokenDescarga?: string | null;
}

export class TokenDescargaQuery implements ITokenDescargaQuery {
  hashArchivo?: string | null;

  constructor(data?: ITokenDescargaQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hashArchivo =
        _data["hashArchivo"] !== undefined ? _data["hashArchivo"] : <any>null;
    }
  }

  static fromJS(data: any): TokenDescargaQuery {
    data = typeof data === "object" ? data : {};
    let result = new TokenDescargaQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["hashArchivo"] =
      this.hashArchivo !== undefined ? this.hashArchivo : <any>null;
    return data;
  }
}

export interface ITokenDescargaQuery {
  hashArchivo?: string | null;
}

export class ConfirmarEmailResponse implements IConfirmarEmailResponse {
  constructor(data?: IConfirmarEmailResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): ConfirmarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ConfirmarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IConfirmarEmailResponse {}

export class IngresarResponse implements IIngresarResponse {
  user?: UserInfo | null;
  token?: string | null;
  refreshToken?: string | null;
  expirationDate?: Date;

  constructor(data?: IIngresarResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data["user"] ? UserInfo.fromJS(_data["user"]) : <any>null;
      this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
      this.expirationDate = _data["expirationDate"]
        ? new Date(_data["expirationDate"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): IngresarResponse {
    data = typeof data === "object" ? data : {};
    let result = new IngresarResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user ? this.user.toJSON() : <any>null;
    data["token"] = this.token !== undefined ? this.token : <any>null;
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    data["expirationDate"] = this.expirationDate
      ? this.expirationDate.toISOString()
      : <any>null;
    return data;
  }
}

export interface IIngresarResponse {
  user?: UserInfo | null;
  token?: string | null;
  refreshToken?: string | null;
  expirationDate?: Date;
}

export class UserInfo implements IUserInfo {
  idUsuario?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  tipoUsuario?: TiposUsuario;
  refreshToken?: string | null;

  constructor(data?: IUserInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idUsuario =
        _data["idUsuario"] !== undefined ? _data["idUsuario"] : <any>null;
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.tipoUsuario =
        _data["tipoUsuario"] !== undefined ? _data["tipoUsuario"] : <any>null;
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
    }
  }

  static fromJS(data: any): UserInfo {
    data = typeof data === "object" ? data : {};
    let result = new UserInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] =
      this.idUsuario !== undefined ? this.idUsuario : <any>null;
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["tipoUsuario"] =
      this.tipoUsuario !== undefined ? this.tipoUsuario : <any>null;
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    return data;
  }
}

export interface IUserInfo {
  idUsuario?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  tipoUsuario?: TiposUsuario;
  refreshToken?: string | null;
}

export enum TiposUsuario {
  User = 0,
  Admin = 1,
}

export class GetUsuarioLoginQuery implements IGetUsuarioLoginQuery {
  nombreUsuario?: string | null;
  password?: string | null;

  constructor(data?: IGetUsuarioLoginQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.password =
        _data["password"] !== undefined ? _data["password"] : <any>null;
    }
  }

  static fromJS(data: any): GetUsuarioLoginQuery {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuarioLoginQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["password"] = this.password !== undefined ? this.password : <any>null;
    return data;
  }
}

export interface IGetUsuarioLoginQuery {
  nombreUsuario?: string | null;
  password?: string | null;
}

export class RefreshCredentialsCommand implements IRefreshCredentialsCommand {
  refreshToken?: string | null;
  token?: string | null;

  constructor(data?: IRefreshCredentialsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
      this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
    }
  }

  static fromJS(data: any): RefreshCredentialsCommand {
    data = typeof data === "object" ? data : {};
    let result = new RefreshCredentialsCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    data["token"] = this.token !== undefined ? this.token : <any>null;
    return data;
  }
}

export interface IRefreshCredentialsCommand {
  refreshToken?: string | null;
  token?: string | null;
}

export class InvalidaTokenResponse implements IInvalidaTokenResponse {
  constructor(data?: IInvalidaTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): InvalidaTokenResponse {
    data = typeof data === "object" ? data : {};
    let result = new InvalidaTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IInvalidaTokenResponse {}

export class InvalidaTokenCommand implements IInvalidaTokenCommand {
  refreshToken?: string | null;

  constructor(data?: IInvalidaTokenCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
    }
  }

  static fromJS(data: any): InvalidaTokenCommand {
    data = typeof data === "object" ? data : {};
    let result = new InvalidaTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    return data;
  }
}

export interface IInvalidaTokenCommand {
  refreshToken?: string | null;
}

export class RecuperaPasswordGeneraTokenResponse
  implements IRecuperaPasswordGeneraTokenResponse {
  constructor(data?: IRecuperaPasswordGeneraTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): RecuperaPasswordGeneraTokenResponse {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordGeneraTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IRecuperaPasswordGeneraTokenResponse {}

export class RecuperaPasswordGeneraTokenCommand
  implements IRecuperaPasswordGeneraTokenCommand {
  email?: string | null;

  constructor(data?: IRecuperaPasswordGeneraTokenCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
    }
  }

  static fromJS(data: any): RecuperaPasswordGeneraTokenCommand {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordGeneraTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email !== undefined ? this.email : <any>null;
    return data;
  }
}

export interface IRecuperaPasswordGeneraTokenCommand {
  email?: string | null;
}

export class RecuperaPasswordResponse implements IRecuperaPasswordResponse {
  constructor(data?: IRecuperaPasswordResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): RecuperaPasswordResponse {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IRecuperaPasswordResponse {}

export class RecuperaPasswordCommand implements IRecuperaPasswordCommand {
  token?: string | null;
  password?: string | null;

  constructor(data?: IRecuperaPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
      this.password =
        _data["password"] !== undefined ? _data["password"] : <any>null;
    }
  }

  static fromJS(data: any): RecuperaPasswordCommand {
    data = typeof data === "object" ? data : {};
    let result = new RecuperaPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token !== undefined ? this.token : <any>null;
    data["password"] = this.password !== undefined ? this.password : <any>null;
    return data;
  }
}

export interface IRecuperaPasswordCommand {
  token?: string | null;
  password?: string | null;
}

export abstract class NotificationResponse implements INotificationResponse {
  notificationMessage?: string | null;

  constructor(data?: INotificationResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notificationMessage =
        _data["notificationMessage"] !== undefined
          ? _data["notificationMessage"]
          : <any>null;
    }
  }

  static fromJS(data: any): NotificationResponse {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'NotificationResponse' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["notificationMessage"] =
      this.notificationMessage !== undefined
        ? this.notificationMessage
        : <any>null;
    return data;
  }
}

export interface INotificationResponse {
  notificationMessage?: string | null;
}

export class CreateUsuarioResponse extends NotificationResponse
  implements ICreateUsuarioResponse {
  id?: number;
  email?: string | null;
  nombreUsuario?: string | null;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;

  constructor(data?: ICreateUsuarioResponse) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
    }
  }

  static fromJS(data: any): CreateUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new CreateUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    super.toJSON(data);
    return data;
  }
}

export interface ICreateUsuarioResponse extends INotificationResponse {
  id?: number;
  email?: string | null;
  nombreUsuario?: string | null;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
}

export class CreateUsuarioCommand implements ICreateUsuarioCommand {
  nombreUsuario?: string | null;
  email?: string | null;
  password?: string | null;
  tipoUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;

  constructor(data?: ICreateUsuarioCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.password =
        _data["password"] !== undefined ? _data["password"] : <any>null;
      this.tipoUsuario =
        _data["tipoUsuario"] !== undefined ? _data["tipoUsuario"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
    }
  }

  static fromJS(data: any): CreateUsuarioCommand {
    data = typeof data === "object" ? data : {};
    let result = new CreateUsuarioCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["password"] = this.password !== undefined ? this.password : <any>null;
    data["tipoUsuario"] =
      this.tipoUsuario !== undefined ? this.tipoUsuario : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    return data;
  }
}

export interface ICreateUsuarioCommand {
  nombreUsuario?: string | null;
  email?: string | null;
  password?: string | null;
  tipoUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
}

export class ReenviarEmailResponse extends NotificationResponse
  implements IReenviarEmailResponse {
  email?: string | null;
  confirmado?: boolean;
  tipoUsuario?: TiposUsuario;
  token?: string | null;

  constructor(data?: IReenviarEmailResponse) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.confirmado =
        _data["confirmado"] !== undefined ? _data["confirmado"] : <any>null;
      this.tipoUsuario =
        _data["tipoUsuario"] !== undefined ? _data["tipoUsuario"] : <any>null;
      this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
    }
  }

  static fromJS(data: any): ReenviarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ReenviarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["confirmado"] =
      this.confirmado !== undefined ? this.confirmado : <any>null;
    data["tipoUsuario"] =
      this.tipoUsuario !== undefined ? this.tipoUsuario : <any>null;
    data["token"] = this.token !== undefined ? this.token : <any>null;
    super.toJSON(data);
    return data;
  }
}

export interface IReenviarEmailResponse extends INotificationResponse {
  email?: string | null;
  confirmado?: boolean;
  tipoUsuario?: TiposUsuario;
  token?: string | null;
}

export class ReenviarEmailCommand implements IReenviarEmailCommand {
  email?: string | null;

  constructor(data?: IReenviarEmailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
    }
  }

  static fromJS(data: any): ReenviarEmailCommand {
    data = typeof data === "object" ? data : {};
    let result = new ReenviarEmailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email !== undefined ? this.email : <any>null;
    return data;
  }
}

export interface IReenviarEmailCommand {
  email?: string | null;
}

export class GetEnfermedadesResponse implements IGetEnfermedadesResponse {
  enfermedades?: EnfermedadLookupModel[] | null;

  constructor(data?: IGetEnfermedadesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["enfermedades"])) {
        this.enfermedades = [] as any;
        for (let item of _data["enfermedades"])
          this.enfermedades!.push(EnfermedadLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEnfermedadesResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetEnfermedadesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.enfermedades)) {
      data["enfermedades"] = [];
      for (let item of this.enfermedades)
        data["enfermedades"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetEnfermedadesResponse {
  enfermedades?: EnfermedadLookupModel[] | null;
}

export class EnfermedadLookupModel implements IEnfermedadLookupModel {
  id?: number;
  nombre?: string | null;

  constructor(data?: IEnfermedadLookupModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): EnfermedadLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new EnfermedadLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IEnfermedadLookupModel {
  id?: number;
  nombre?: string | null;
}

export class GetEtapaFenologicaListResponse
  implements IGetEtapaFenologicaListResponse {
  etapas?: EtapaLookUpModel[] | null;

  constructor(data?: IGetEtapaFenologicaListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["etapas"])) {
        this.etapas = [] as any;
        for (let item of _data["etapas"])
          this.etapas!.push(EtapaLookUpModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetEtapaFenologicaListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetEtapaFenologicaListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.etapas)) {
      data["etapas"] = [];
      for (let item of this.etapas) data["etapas"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetEtapaFenologicaListResponse {
  etapas?: EtapaLookUpModel[] | null;
}

export class EtapaLookUpModel implements IEtapaLookUpModel {
  id?: number;
  nombre?: string | null;

  constructor(data?: IEtapaLookUpModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): EtapaLookUpModel {
    data = typeof data === "object" ? data : {};
    let result = new EtapaLookUpModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IEtapaLookUpModel {
  id?: number;
  nombre?: string | null;
}

export class GetPlagasResponse implements IGetPlagasResponse {
  plagas?: PlagaLookupModel[] | null;

  constructor(data?: IGetPlagasResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["plagas"])) {
        this.plagas = [] as any;
        for (let item of _data["plagas"])
          this.plagas!.push(PlagaLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetPlagasResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetPlagasResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.plagas)) {
      data["plagas"] = [];
      for (let item of this.plagas) data["plagas"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetPlagasResponse {
  plagas?: PlagaLookupModel[] | null;
}

export class PlagaLookupModel implements IPlagaLookupModel {
  id?: number;
  nombre?: string | null;

  constructor(data?: IPlagaLookupModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
    }
  }

  static fromJS(data: any): PlagaLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new PlagaLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    return data;
  }
}

export interface IPlagaLookupModel {
  id?: number;
  nombre?: string | null;
}

export class GetUsuariosListResponse implements IGetUsuariosListResponse {
  usuarios?: UsuarioLookupModel[] | null;

  constructor(data?: IGetUsuariosListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["usuarios"])) {
        this.usuarios = [] as any;
        for (let item of _data["usuarios"])
          this.usuarios!.push(UsuarioLookupModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetUsuariosListResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuariosListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.usuarios)) {
      data["usuarios"] = [];
      for (let item of this.usuarios) data["usuarios"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetUsuariosListResponse {
  usuarios?: UsuarioLookupModel[] | null;
}

export class UsuarioLookupModel implements IUsuarioLookupModel {
  id?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
  tipoUsuario?: TiposUsuario;
  confirmado?: boolean;

  constructor(data?: IUsuarioLookupModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
      this.tipoUsuario =
        _data["tipoUsuario"] !== undefined ? _data["tipoUsuario"] : <any>null;
      this.confirmado =
        _data["confirmado"] !== undefined ? _data["confirmado"] : <any>null;
    }
  }

  static fromJS(data: any): UsuarioLookupModel {
    data = typeof data === "object" ? data : {};
    let result = new UsuarioLookupModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id !== undefined ? this.id : <any>null;
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    data["tipoUsuario"] =
      this.tipoUsuario !== undefined ? this.tipoUsuario : <any>null;
    data["confirmado"] =
      this.confirmado !== undefined ? this.confirmado : <any>null;
    return data;
  }
}

export interface IUsuarioLookupModel {
  id?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
  tipoUsuario?: TiposUsuario;
  confirmado?: boolean;
}

export class GetUsuarioDetailResponse implements IGetUsuarioDetailResponse {
  idUsuario?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  tipoUsuario?: TiposUsuario;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;

  constructor(data?: IGetUsuarioDetailResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idUsuario =
        _data["idUsuario"] !== undefined ? _data["idUsuario"] : <any>null;
      this.nombreUsuario =
        _data["nombreUsuario"] !== undefined
          ? _data["nombreUsuario"]
          : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.tipoUsuario =
        _data["tipoUsuario"] !== undefined ? _data["tipoUsuario"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
    }
  }

  static fromJS(data: any): GetUsuarioDetailResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUsuarioDetailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] =
      this.idUsuario !== undefined ? this.idUsuario : <any>null;
    data["nombreUsuario"] =
      this.nombreUsuario !== undefined ? this.nombreUsuario : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["tipoUsuario"] =
      this.tipoUsuario !== undefined ? this.tipoUsuario : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    return data;
  }
}

export interface IGetUsuarioDetailResponse {
  idUsuario?: number;
  nombreUsuario?: string | null;
  email?: string | null;
  tipoUsuario?: TiposUsuario;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
}

export class AproveUsuarioResponse implements IAproveUsuarioResponse {
  constructor(data?: IAproveUsuarioResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): AproveUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new AproveUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IAproveUsuarioResponse {}

export class DeleteUsuarioResponse implements IDeleteUsuarioResponse {
  constructor(data?: IDeleteUsuarioResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): DeleteUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new DeleteUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IDeleteUsuarioResponse {}

export class ModificarDatosUsuarioResponse
  implements IModificarDatosUsuarioResponse {
  idUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;

  constructor(data?: IModificarDatosUsuarioResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idUsuario =
        _data["idUsuario"] !== undefined ? _data["idUsuario"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
    }
  }

  static fromJS(data: any): ModificarDatosUsuarioResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarDatosUsuarioResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] =
      this.idUsuario !== undefined ? this.idUsuario : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    return data;
  }
}

export interface IModificarDatosUsuarioResponse {
  idUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
}

export class ModificarDatosUsuarioCommand
  implements IModificarDatosUsuarioCommand {
  idUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;

  constructor(data?: IModificarDatosUsuarioCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idUsuario =
        _data["idUsuario"] !== undefined ? _data["idUsuario"] : <any>null;
      this.nombre = _data["nombre"] !== undefined ? _data["nombre"] : <any>null;
      this.apellidoPaterno =
        _data["apellidoPaterno"] !== undefined
          ? _data["apellidoPaterno"]
          : <any>null;
      this.apellidoMaterno =
        _data["apellidoMaterno"] !== undefined
          ? _data["apellidoMaterno"]
          : <any>null;
    }
  }

  static fromJS(data: any): ModificarDatosUsuarioCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarDatosUsuarioCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idUsuario"] =
      this.idUsuario !== undefined ? this.idUsuario : <any>null;
    data["nombre"] = this.nombre !== undefined ? this.nombre : <any>null;
    data["apellidoPaterno"] =
      this.apellidoPaterno !== undefined ? this.apellidoPaterno : <any>null;
    data["apellidoMaterno"] =
      this.apellidoMaterno !== undefined ? this.apellidoMaterno : <any>null;
    return data;
  }
}

export interface IModificarDatosUsuarioCommand {
  idUsuario?: number;
  nombre?: string | null;
  apellidoPaterno?: string | null;
  apellidoMaterno?: string | null;
}

export class ModificarEmailResponse implements IModificarEmailResponse {
  email?: string | null;

  constructor(data?: IModificarEmailResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
    }
  }

  static fromJS(data: any): ModificarEmailResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarEmailResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email !== undefined ? this.email : <any>null;
    return data;
  }
}

export interface IModificarEmailResponse {
  email?: string | null;
}

export class ModificarEmailCommand implements IModificarEmailCommand {
  nuevoEmail?: string | null;
  password?: string | null;

  constructor(data?: IModificarEmailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nuevoEmail =
        _data["nuevoEmail"] !== undefined ? _data["nuevoEmail"] : <any>null;
      this.password =
        _data["password"] !== undefined ? _data["password"] : <any>null;
    }
  }

  static fromJS(data: any): ModificarEmailCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarEmailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["nuevoEmail"] =
      this.nuevoEmail !== undefined ? this.nuevoEmail : <any>null;
    data["password"] = this.password !== undefined ? this.password : <any>null;
    return data;
  }
}

export interface IModificarEmailCommand {
  nuevoEmail?: string | null;
  password?: string | null;
}

export class ModificarPasswordResponse extends NotificationResponse
  implements IModificarPasswordResponse {
  email?: string | null;

  constructor(data?: IModificarPasswordResponse) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
    }
  }

  static fromJS(data: any): ModificarPasswordResponse {
    data = typeof data === "object" ? data : {};
    let result = new ModificarPasswordResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email !== undefined ? this.email : <any>null;
    super.toJSON(data);
    return data;
  }
}

export interface IModificarPasswordResponse extends INotificationResponse {
  email?: string | null;
}

export class ModificarPasswordCommand implements IModificarPasswordCommand {
  passwordActual?: string | null;
  passwordNuevo?: string | null;

  constructor(data?: IModificarPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.passwordActual =
        _data["passwordActual"] !== undefined
          ? _data["passwordActual"]
          : <any>null;
      this.passwordNuevo =
        _data["passwordNuevo"] !== undefined
          ? _data["passwordNuevo"]
          : <any>null;
    }
  }

  static fromJS(data: any): ModificarPasswordCommand {
    data = typeof data === "object" ? data : {};
    let result = new ModificarPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["passwordActual"] =
      this.passwordActual !== undefined ? this.passwordActual : <any>null;
    data["passwordNuevo"] =
      this.passwordNuevo !== undefined ? this.passwordNuevo : <any>null;
    return data;
  }
}

export interface IModificarPasswordCommand {
  passwordActual?: string | null;
  passwordNuevo?: string | null;
}

export class AgregarImagenPerfilResponse
  implements IAgregarImagenPerfilResponse {
  constructor(data?: IAgregarImagenPerfilResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): AgregarImagenPerfilResponse {
    data = typeof data === "object" ? data : {};
    let result = new AgregarImagenPerfilResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IAgregarImagenPerfilResponse {}

export class AgregarImagenPerfilCommand implements IAgregarImagenPerfilCommand {
  imagen?: string | null;

  constructor(data?: IAgregarImagenPerfilCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.imagen = _data["imagen"] !== undefined ? _data["imagen"] : <any>null;
    }
  }

  static fromJS(data: any): AgregarImagenPerfilCommand {
    data = typeof data === "object" ? data : {};
    let result = new AgregarImagenPerfilCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["imagen"] = this.imagen !== undefined ? this.imagen : <any>null;
    return data;
  }
}

export interface IAgregarImagenPerfilCommand {
  imagen?: string | null;
}

export enum MySize {
  Small = 0,
  Medium = 1,
  Large = 2,
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
